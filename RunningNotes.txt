DOCKER ----------------------------------------------

docker run -it redis (run redis commands in a terminal)
Image --> Single file with all dependecies and config required to run a program
Container -->  Runtime instance of an image

Docker Ecosystem
Docker client (running commands or docker cli)
Docker server (responsible for creating images, running containers etc)
Docker machine
Docker Images
Docker compose
Docker Hub

*** Docker client does some processing on commands enetered and docker server does the heavy lifting
*** Docker server looks for image cache first if it dosent find then downloads from priavte repo/docker hub.
when running docker on mac/windows it actually installs a Linux VM and then runs processes in the VM.

docker logs container-id (Get logs of a container)
docker stop container-id || docker kill container-id
docker rm container-id
docker ps || docker ps --all

Redis 
docker run redis (Runs the redis server on port 6379 in a container)
To connect to a container then use docker exec -it container-id redis-cli 

Terminal in Container
docker exec -it container-id sh|bash (Run command prompt in a container)
also can use docker run -it image sh
containers always run in isolation
docker container prune (deletes all containers)

DockerFile
base image  FROM
Run some commands  RUN
commnad to run on container startup  CMD
docker build -t avemula/nginx:latest .

SAMPLE NODE JS APP
docker run -it avemula/sample-node sh
docker exec -it container-id sh
ls will show all the files
exit to get out of container or ctrl+c or ctrl+d
copy package.json and run npm install and then copy all remaining  this will allow cache for the dependecies and then if u change index.js file build would be fast

DOCKER COMPOSE
docker-compose up -d
docker-compose down
restart: always --> always restarts the containers when container start fails
docker-compose ps (similar to docker ps)

-f to specify different docker file (-f Dockerfile.dev)
React APP
Start react app in local docker container
docker run -p 3000:3000 -v $(pwd):/app image-id -v /app/node_modules (if we want to use container node modules)
docker exec -it container-id npm run test(can specify different commands to running container)

Kubernetes------------------------------------------------------
what is kubernetes?  system for running many different containers over multiple VM's.
why use kubernetes? when you need to run many diffrent containers with different images.

Can scale up individual services instead of whole app (client, nginx, server) we could just increase server instances.
Running many different containers in multiple different virtual machines.

Development --> mini cube (command line tool)
Production --> Amazon elastic container service, google cloud Kubernetes engine

(installed kubectl, virtualBox, miniKube for local Development).
*** minikube to used to install kubernetes cluster, and kubectl is used to interact with the cluster. (Local Development)
*** minikube start (installed a vm on local conmputer) which is called Node.

Checking if miniKube & Kubectl Started
kubectl cluster-info (checking status)
miniKube status
minikube ip

config File (used to  create objects) ==> StatefulSet, ReplicaContainer, Pod, Service (running a container, monitoring a container, setting up networking)
*** Pod means running 1 or more closely related containers. 
*** Service means setup Networking in Kubernetes Cluster.
*** Deployment maintains set of identical pods, ensuring they have correct config and right number exists.

*** Smallest deployable unit in kubernetes is a Pod(a pod has to have 1 or more containers).

Object Types
Pod (used for Development)
Deployment (used in Production)
Service Types 
ClusterIP 
NodePort (Expose container to outside world only for development) 
LoadBalancer 
Ingress

YAML File
**** Selector component in node port file is used to identify how to route traffic to a pod. (labels is how its defined in a pod file)
nodePort would be in b/w (30000 - 32767)

Execute config files
kubectl apply -f filename (we will always interact with master node & feed commands to master)
kubectl delete -f filename (will remove the pod)
All Kubectl commands are feeded to master node. we dont reallly touch the node/VM master takes care of it.

Get Status of deployed Pods / services/deployments
kubectl get pods -o wide
kubectl get services
kubectl get deployments
kubectl describe pod name-of-object

*** Each node/VM has a docker preinstalled , downloads the image from docker hub & runs the image in a container.
*** We will be following declarative approach all the time.

*** Updating a config file (have the same name & type always & then update remaining things). Name is the unique ID
if its a new name then master will create a new pod.

*** to need details for an object command is kubectl describe pod name-of-object 

Deployment pod Template
containers: 1  
name: client (container name)
port: 3000   (port number)
image: multi-client (docker image)

*** Labels are the only way to identify which pod we are referring to. (selector in service object and matchLables in deployment object matches that)
*** PODS IP ADDRESS keep changing so we therefore we use service objects to connect to the pod

How to recreate our pods with latest version of multi-client image pushed to docker hub
1.push updated docker image to docker hub with new versio & update kubernete config file with new version.
2. Imperative command push updted image to docker hub with tag & apply this command
kubectl set image deployment/client-deployment client=anirudhreddy18/multi-client

*** eval $(minikube docker-env) ---- connects to docker server in kubernetes node (runs only in current terminal) why? still use docker cli commands for debugging 
